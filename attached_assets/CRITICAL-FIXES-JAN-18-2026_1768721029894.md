# CRITICAL FIX SPECIFICATIONS - JANUARY 18, 2026 AUDIT
## The Archivist Method - 5 Launch Blockers

**Audit Date:** January 18, 2026  
**Status:** üî¥ BLOCKS LAUNCH  
**Total Fix Time:** 8.5 hours  
**Priority:** Complete all 5 before launch

---

## FIX #1: BRAND VIOLATION - "HEALING" LANGUAGE

### **Issue:**
The word "healing" appears in Footer FAQ, violating the "NOT therapy" core directive.

**Location Found:**
- Footer FAQ, Question 3: "How long does the healing process take?"
- Confirmation Email: "Join our community of *thrivers*"

**Brand Rule Violated:**
- ‚ùå NO therapy language: "healing", "thrive", "self-help"
- ‚úÖ YES pattern interruption language: "reprogram", "interrupt", "decode"

---

### **Fix Specification:**

**Step 1: Global Search**

Search entire codebase for therapy-adjacent language:
```bash
grep -ri "healing" ./src
grep -ri "heal" ./src
grep -ri "thrive" ./src
grep -ri "thrivers" ./src
```

**Step 2: Fix Footer FAQ**

**Location:** Footer FAQ component or content file

**BEFORE:**
```html
<h3>How long does the healing process take?</h3>
<p>The healing journey is different for everyone...</p>
```

**AFTER:**
```html
<h3>How long does the reprogramming window last?</h3>
<p>Pattern interruption timing varies by nervous system. Most users see their first successful interrupt within 7 days.</p>
```

**Alternative options:**
- "How long until the pattern interrupts?"
- "What's the timeline for pattern archaeology?"
- "How quickly do patterns shift?"

**Step 3: Fix Confirmation Email**

**Location:** Email templates directory
- `/src/emails/confirmation.tsx`
- `/lib/email-templates/`
- Email provider (ConvertKit/Mailchimp) if using external

**BEFORE:**
```
Welcome! Join our community of thrivers.
```

**AFTER:**
```
Access granted. Join the archive.
```

**Step 4: Approved Replacement Terms**

Use these instead of "heal/healing/thrive":
- ‚úÖ "reprogram"
- ‚úÖ "interrupt"
- ‚úÖ "decode"
- ‚úÖ "dismantle"
- ‚úÖ "excavate"
- ‚úÖ "recode"
- ‚úÖ "shift"

**Step 5: Complete Brand Audit**

Check these locations:
```
Priority:
- /src/components/Footer.tsx
- /src/components/FAQ.tsx
- /src/emails/ (all templates)
- /content/ (if using markdown)
- Meta descriptions
- Email sequences

Secondary:
- Testimonials (check for user-submitted "heal" language)
- Blog posts (if exist)
- About page
```

---

### **Testing Checklist:**

- [ ] Global search for "heal" returns ZERO results
- [ ] Global search for "thrive" returns ZERO results  
- [ ] Footer FAQ uses "reprogram" language
- [ ] Confirmation email uses "archive" language
- [ ] All meta descriptions checked
- [ ] Brand voice consistent (clinical, not therapeutic)

### **Time Estimate:** 15 minutes

---

## FIX #2: MOBILE PRICING TABLE OVERFLOW

### **Issue:**
On `/portal/crash-course`, the 3-column pricing comparison table is cut off on the right side on mobile (<390px width). Users cannot see the "$197" Archive column.

**Reproduction:**
1. Open `/portal/crash-course` on iPhone 13/14 (width <390px)
2. Scroll to "Upgrade Options" section
3. See 3-column table (Crash Course, Quick-Start, Archive)
4. Right column (Archive $197) is cut off
5. No visual indicator that horizontal scroll is available

**Impact:** Users can't see premium option = lost $197 sales

---

### **Fix Specification:**

**Solution:** Make table horizontally scrollable on mobile with visual scroll indicator.

---

### **Implementation:**

**Step 1: Locate Pricing Table**

Find the comparison table component:
```
Likely locations:
- /src/pages/portal/crash-course.tsx
- /src/components/portal/UpgradeTable.tsx
- /src/app/portal/crash-course/page.tsx
```

**Step 2: Add Scroll Container**

**BEFORE:**
```jsx
<div className="pricing-comparison">
  <table className="comparison-table">
    <thead>
      <tr>
        <th>Crash Course</th>
        <th>Quick-Start ($47)</th>
        <th>Archive ($197)</th>
      </tr>
    </thead>
    <tbody>
      {/* rows */}
    </tbody>
  </table>
</div>
```

**AFTER:**
```jsx
<div className="pricing-comparison">
  {/* Add scroll container wrapper */}
  <div className="table-scroll-container">
    <table className="comparison-table">
      <thead>
        <tr>
          <th>Crash Course</th>
          <th>Quick-Start ($47)</th>
          <th>Archive ($197)</th>
        </tr>
      </thead>
      <tbody>
        {/* rows */}
      </tbody>
    </table>
  </div>
  
  {/* Add scroll indicator */}
  <div className="scroll-indicator" aria-label="Scroll right to see all options">
    <svg>‚Üí</svg>
    <span>Swipe to see all tiers</span>
  </div>
</div>
```

**Step 3: Add CSS**

```css
/* Desktop - normal display */
.pricing-comparison {
  width: 100%;
  position: relative;
}

.comparison-table {
  width: 100%;
  border-collapse: collapse;
}

/* Mobile - scrollable */
@media (max-width: 768px) {
  .table-scroll-container {
    overflow-x: auto;
    overflow-y: visible;
    -webkit-overflow-scrolling: touch; /* Smooth iOS scroll */
    position: relative;
  }
  
  /* Visual gradient hint that content continues */
  .table-scroll-container::after {
    content: '';
    position: absolute;
    top: 0;
    right: 0;
    width: 40px;
    height: 100%;
    background: linear-gradient(
      to left,
      rgba(10, 10, 10, 0.9) 0%,
      rgba(10, 10, 10, 0) 100%
    );
    pointer-events: none;
    transition: opacity 0.3s;
  }
  
  /* Hide gradient after user scrolls */
  .table-scroll-container.scrolled::after {
    opacity: 0;
  }
  
  .comparison-table {
    min-width: 600px; /* Ensure table doesn't collapse */
  }
  
  /* Scroll indicator */
  .scroll-indicator {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    padding: 12px;
    color: #14B8A6;
    font-size: 14px;
    animation: bounce-horizontal 2s infinite;
  }
  
  .scroll-indicator svg {
    width: 20px;
    height: 20px;
    fill: #14B8A6;
  }
  
  @keyframes bounce-horizontal {
    0%, 100% { transform: translateX(0); }
    50% { transform: translateX(10px); }
  }
}

/* Desktop - hide scroll indicator */
@media (min-width: 769px) {
  .scroll-indicator {
    display: none;
  }
}
```

**Step 4: Add JavaScript for Scroll Tracking**

```javascript
// Remove gradient indicator after user scrolls
useEffect(() => {
  const container = document.querySelector('.table-scroll-container');
  
  if (!container) return;
  
  const handleScroll = () => {
    if (container.scrollLeft > 10) {
      container.classList.add('scrolled');
    } else {
      container.classList.remove('scrolled');
    }
  };
  
  container.addEventListener('scroll', handleScroll);
  return () => container.removeEventListener('scroll', handleScroll);
}, []);
```

---

### **ALTERNATIVE SOLUTION: Stacked Cards on Mobile**

If horizontal scroll feels clunky, switch to vertical stacked cards on mobile:

```css
@media (max-width: 768px) {
  .comparison-table {
    display: none; /* Hide table on mobile */
  }
  
  .pricing-cards {
    display: flex;
    flex-direction: column;
    gap: 20px;
  }
  
  .pricing-card {
    background: #1a1a1a;
    border: 1px solid #333;
    border-radius: 8px;
    padding: 24px;
  }
  
  .pricing-card.featured {
    border: 2px solid #14B8A6;
    box-shadow: 0 0 20px rgba(20, 184, 166, 0.2);
  }
}

@media (min-width: 769px) {
  .pricing-cards {
    display: none; /* Hide cards on desktop */
  }
}
```

**HTML for stacked cards:**
```jsx
{/* Desktop: Table */}
<table className="comparison-table">
  {/* existing table */}
</table>

{/* Mobile: Stacked Cards */}
<div className="pricing-cards">
  <div className="pricing-card">
    <h3>Crash Course</h3>
    <p className="price">FREE</p>
    <ul>
      <li>7-day protocol</li>
      <li>Body signature guide</li>
      <li>Circuit break basics</li>
    </ul>
    <button className="cta-secondary">Current Tier</button>
  </div>
  
  <div className="pricing-card featured">
    <span className="badge">RECOMMENDED</span>
    <h3>Quick-Start System</h3>
    <p className="price">$47</p>
    <ul>
      <li>Everything in Crash Course</li>
      <li>90-day reprogramming protocol</li>
      <li>Pattern interrupt library</li>
      <li>Emergency circuit breaks</li>
    </ul>
    <button className="cta-primary">Upgrade Now</button>
  </div>
  
  <div className="pricing-card">
    <h3>Complete Archive</h3>
    <p className="price">$197</p>
    <ul>
      <li>Everything in Quick-Start</li>
      <li>All 7 pattern protocols</li>
      <li>Advanced interruption techniques</li>
      <li>Lifetime access</li>
    </ul>
    <button className="cta-primary">Get Full Access</button>
  </div>
</div>
```

---

### **Testing Checklist:**

**Mobile (<390px width):**
- [ ] Can see all 3 columns (Crash Course, Quick-Start, Archive)
- [ ] Horizontal scroll works smoothly
- [ ] Visual indicator shows more content available
- [ ] Gradient fades after scrolling
- [ ] All prices visible ($47, $197)
- [ ] Touch scroll is smooth (not janky)

**Tablet (390-768px):**
- [ ] Table displays correctly
- [ ] All columns visible

**Desktop (>768px):**
- [ ] Table displays normally
- [ ] No scroll container or indicator
- [ ] All columns visible side-by-side

**Accessibility:**
- [ ] Keyboard users can scroll with arrow keys
- [ ] Screen readers announce scrollable region
- [ ] Focus doesn't get trapped

### **Time Estimate:** 1 hour

---

## FIX #3: PORTAL UPGRADE LINK BROKEN

### **Issue:**
The "Upgrade to Archive" button in the Quick-Start portal redirects to the generic Homepage instead of directly to Checkout. This forces users to re-navigate the entire sales funnel, causing friction and abandoned upgrades.

**Reproduction:**
1. Log in as Quick-Start user
2. Go to portal dashboard
3. Click "Upgrade to Archive" button
4. Redirected to Homepage (not Checkout)
5. User must scroll, find pricing, click again

**Impact:** Conversion killer - users abandon upgrade

---

### **Fix Specification:**

**Solution:** Direct link to Stripe Checkout with user context pre-filled.

---

### **Implementation:**

**Step 1: Locate Upgrade Button**

Find the upgrade CTA component:
```
Likely locations:
- /src/pages/portal/dashboard.tsx
- /src/components/portal/UpgradePrompt.tsx
- /src/components/portal/QuickStartUpsell.tsx
```

**Step 2: Fix Button Link**

**BEFORE:**
```jsx
<Link href="/" className="upgrade-button">
  Upgrade to Archive
</Link>
```

**AFTER (Direct Stripe Checkout):**
```jsx
<Link 
  href="/checkout/archive"
  className="upgrade-button"
>
  Upgrade to Archive
</Link>
```

**OR (Better - Pre-populated Stripe Session):**
```jsx
<button 
  onClick={handleUpgrade}
  className="upgrade-button"
>
  Upgrade to Archive - $197
</button>
```

**Step 3: Create Upgrade Handler**

```javascript
const handleUpgrade = async () => {
  try {
    // Create Stripe checkout session
    const response = await fetch('/api/checkout/create-session', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        priceId: process.env.NEXT_PUBLIC_ARCHIVE_PRICE_ID,
        userId: user.id,
        email: user.email,
        upgradeFrom: 'quick-start', // Track upgrade path
        successUrl: `${window.location.origin}/portal/dashboard?upgrade=success`,
        cancelUrl: `${window.location.origin}/portal/dashboard?upgrade=cancelled`,
      }),
    });
    
    const { sessionId } = await response.json();
    
    // Redirect to Stripe Checkout
    const stripe = await getStripe();
    await stripe.redirectToCheckout({ sessionId });
    
  } catch (error) {
    console.error('Upgrade failed:', error);
    // Show error message to user
    setError('Could not initiate upgrade. Please try again.');
  }
};
```

**Step 4: Create API Endpoint**

**File:** `/pages/api/checkout/create-session.ts` (or `/app/api/checkout/create-session/route.ts`)

```typescript
import Stripe from 'stripe';
import { NextApiRequest, NextApiResponse } from 'next';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: '2023-10-16',
});

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }
  
  const { priceId, userId, email, upgradeFrom, successUrl, cancelUrl } = req.body;
  
  try {
    // Create Stripe checkout session
    const session = await stripe.checkout.sessions.create({
      mode: 'payment',
      payment_method_types: ['card'],
      line_items: [
        {
          price: priceId,
          quantity: 1,
        },
      ],
      customer_email: email,
      client_reference_id: userId,
      metadata: {
        userId,
        upgradeFrom,
        product: 'archive',
      },
      success_url: successUrl,
      cancel_url: cancelUrl,
    });
    
    return res.status(200).json({ sessionId: session.id });
    
  } catch (error) {
    console.error('Checkout session creation failed:', error);
    return res.status(500).json({ error: 'Checkout failed' });
  }
}
```

**Step 5: Add Loading State**

```jsx
const [isUpgrading, setIsUpgrading] = useState(false);
const [error, setError] = useState(null);

const handleUpgrade = async () => {
  setIsUpgrading(true);
  setError(null);
  
  try {
    // ... stripe checkout logic
  } catch (error) {
    setError('Upgrade failed. Please try again.');
  } finally {
    setIsUpgrading(false);
  }
};

return (
  <div className="upgrade-prompt">
    <h3>Ready for the Complete Archive?</h3>
    <p>Get access to all 7 patterns + advanced protocols</p>
    
    <button 
      onClick={handleUpgrade}
      disabled={isUpgrading}
      className="upgrade-button"
    >
      {isUpgrading ? (
        <>
          <LoadingSpinner />
          Processing...
        </>
      ) : (
        'Upgrade to Archive - $197'
      )}
    </button>
    
    {error && <p className="error-message">{error}</p>}
  </div>
);
```

---

### **Alternative: Static Checkout Page**

If Stripe dynamic sessions are complex, create a dedicated upgrade page:

**File:** `/pages/upgrade/archive.tsx`

```tsx
export default function ArchiveUpgradePage() {
  const { user } = useAuth();
  
  return (
    <div className="upgrade-page">
      <h1>Upgrade to Complete Archive</h1>
      
      <div className="comparison">
        <div className="current-tier">
          <h2>Your Current Access</h2>
          <p>Quick-Start System ($47)</p>
          <ul>
            <li>90-day protocol</li>
            <li>Pattern interrupt library</li>
          </ul>
        </div>
        
        <div className="upgrade-tier">
          <h2>Complete Archive</h2>
          <p>$197 (One-time)</p>
          <ul>
            <li>Everything in Quick-Start</li>
            <li>All 7 pattern protocols</li>
            <li>Advanced techniques</li>
            <li>Lifetime access</li>
          </ul>
        </div>
      </div>
      
      <StripeCheckout
        priceId={process.env.NEXT_PUBLIC_ARCHIVE_PRICE_ID}
        email={user.email}
        userId={user.id}
      />
    </div>
  );
}
```

Then link to `/upgrade/archive` instead of homepage.

---

### **Testing Checklist:**

**Functional:**
- [ ] Click "Upgrade to Archive" button
- [ ] Redirects to Stripe Checkout (not homepage)
- [ ] Email pre-filled in Checkout
- [ ] Stripe loads correctly
- [ ] After payment, redirects to portal
- [ ] Access granted immediately (or within webhook delay)

**User Experience:**
- [ ] Button shows loading state during redirect
- [ ] Error message displays if Checkout fails
- [ ] Button cannot be clicked multiple times
- [ ] User can cancel and return to dashboard

**Edge Cases:**
- [ ] User already has Archive access - button hidden or disabled
- [ ] Network failure during Checkout creation - error shown
- [ ] User abandons Stripe Checkout - returns to dashboard cleanly

### **Time Estimate:** 2 hours

---

## FIX #4: ADMIN SESSION TIMEOUT MISSING

### **Issue:**
Admin panel session does not expire. A logged-in admin can leave the tab open overnight and still have full access without re-authentication.

**Security Risk:** HIGH

**Scenario:**
- Admin logs in at 9:00 AM
- Leaves tab open
- At 9:00 PM (12 hours later), can still delete users without re-auth
- If laptop is stolen/accessed, attacker has unlimited admin access

---

### **Fix Specification:**

**Solution:** Implement 60-minute server-side token expiry + client-side auto-logout.

---

### **Implementation:**

**Step 1: Server-Side Token Expiry**

**Location:** Auth token generation (likely in `/lib/auth.ts` or `/pages/api/auth/login.ts`)

**BEFORE:**
```javascript
const token = jwt.sign(
  { 
    userId: user.id,
    role: user.role 
  },
  process.env.JWT_SECRET
  // No expiration set
);
```

**AFTER:**
```javascript
const token = jwt.sign(
  { 
    userId: user.id,
    role: user.role 
  },
  process.env.JWT_SECRET,
  { 
    expiresIn: '60m' // 60 minutes for admin role
  }
);
```

**Step 2: Role-Based Expiry**

Different expiry times for different roles:

```javascript
const getTokenExpiry = (role) => {
  switch (role) {
    case 'admin':
      return '60m'; // 1 hour for admins (stricter)
    case 'user':
      return '7d'; // 7 days for regular users
    default:
      return '24h';
  }
};

const token = jwt.sign(
  { userId: user.id, role: user.role },
  process.env.JWT_SECRET,
  { expiresIn: getTokenExpiry(user.role) }
);
```

**Step 3: Verify Token on Protected Routes**

**Location:** Middleware or API route protection

```typescript
// middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import jwt from 'jsonwebtoken';

export function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;
  
  // Protect admin routes
  if (pathname.startsWith('/admin')) {
    const token = request.cookies.get('auth_token')?.value;
    
    if (!token) {
      return NextResponse.redirect(new URL('/admin/login', request.url));
    }
    
    try {
      // Verify token is valid and not expired
      const decoded = jwt.verify(token, process.env.JWT_SECRET!);
      
      // Check if user is admin
      if (decoded.role !== 'admin') {
        return NextResponse.redirect(new URL('/admin/login', request.url));
      }
      
      // Token valid, allow access
      return NextResponse.next();
      
    } catch (error) {
      // Token expired or invalid
      const response = NextResponse.redirect(new URL('/admin/login', request.url));
      response.cookies.delete('auth_token'); // Clear invalid token
      return response;
    }
  }
  
  return NextResponse.next();
}

export const config = {
  matcher: ['/admin/:path*'],
};
```

**Step 4: Client-Side Auto-Logout**

**Location:** Admin layout component or global admin context

```typescript
// /components/admin/AdminLayout.tsx
import { useEffect, useState } from 'react';
import { useRouter } from 'next/router';

export default function AdminLayout({ children }) {
  const router = useRouter();
  const [lastActivity, setLastActivity] = useState(Date.now());
  const TIMEOUT_DURATION = 60 * 60 * 1000; // 60 minutes in ms
  
  // Track user activity
  useEffect(() => {
    const updateActivity = () => setLastActivity(Date.now());
    
    window.addEventListener('mousemove', updateActivity);
    window.addEventListener('keydown', updateActivity);
    window.addEventListener('click', updateActivity);
    
    return () => {
      window.removeEventListener('mousemove', updateActivity);
      window.removeEventListener('keydown', updateActivity);
      window.removeEventListener('click', updateActivity);
    };
  }, []);
  
  // Check for inactivity
  useEffect(() => {
    const checkTimeout = setInterval(() => {
      const timeSinceLastActivity = Date.now() - lastActivity;
      
      if (timeSinceLastActivity > TIMEOUT_DURATION) {
        // Log out user
        handleLogout();
      }
    }, 60000); // Check every minute
    
    return () => clearInterval(checkTimeout);
  }, [lastActivity]);
  
  const handleLogout = async () => {
    // Clear token
    await fetch('/api/auth/logout', { method: 'POST' });
    
    // Redirect to login with timeout message
    router.push('/admin/login?reason=timeout');
  };
  
  return <div className="admin-layout">{children}</div>;
}
```

**Step 5: Show Timeout Warning**

Give admin a 5-minute warning before logout:

```typescript
const [showWarning, setShowWarning] = useState(false);
const WARNING_BUFFER = 5 * 60 * 1000; // 5 minutes

useEffect(() => {
  const checkTimeout = setInterval(() => {
    const timeSinceLastActivity = Date.now() - lastActivity;
    const timeRemaining = TIMEOUT_DURATION - timeSinceLastActivity;
    
    if (timeRemaining <= WARNING_BUFFER && timeRemaining > 0) {
      setShowWarning(true);
    } else if (timeRemaining <= 0) {
      handleLogout();
    } else {
      setShowWarning(false);
    }
  }, 60000);
  
  return () => clearInterval(checkTimeout);
}, [lastActivity]);

return (
  <div className="admin-layout">
    {showWarning && (
      <div className="timeout-warning">
        <p>Your session will expire in 5 minutes due to inactivity.</p>
        <button onClick={() => setLastActivity(Date.now())}>
          Stay Logged In
        </button>
      </div>
    )}
    {children}
  </div>
);
```

---

### **Testing Checklist:**

**Server-Side:**
- [ ] Generate admin token - verify `expiresIn` is set to 60m
- [ ] Wait 61 minutes - token should be invalid
- [ ] Try to access admin route with expired token - redirects to login
- [ ] Invalid token is cleared from cookies

**Client-Side:**
- [ ] Admin logs in
- [ ] No activity for 55 minutes - warning appears
- [ ] Click "Stay Logged In" - resets timer
- [ ] No activity for 60 minutes - auto-logout
- [ ] Redirected to login page with timeout message

**Edge Cases:**
- [ ] Multiple admin tabs open - all logout simultaneously
- [ ] Admin closes tab and reopens - must re-login if >60 min
- [ ] Regular user session - longer expiry (7 days works)

**Security:**
- [ ] Expired token cannot be reused
- [ ] Malformed token is rejected
- [ ] Token without `role: admin` is rejected on admin routes

### **Time Estimate:** 3 hours

---

## FIX #5: QUIZ FALLBACK LOGIC MISSING

### **Issue:**
If a user selects "Neutral" for every question in the Pattern Assessment Quiz, the system throws a JavaScript error `Uncaught TypeError: Cannot read property 'pattern_id' of null` instead of delivering a result.

**Reproduction:**
1. Start Pattern Assessment Quiz
2. Select "Neutral" (middle option) for all questions
3. Click "Submit" or "See Results"
4. JavaScript error crashes page
5. User sees blank screen or error message

**Impact:** Quiz abandonment, looks broken, loses leads

---

### **Fix Specification:**

**Solution:** Add fallback logic to handle edge cases where no dominant pattern emerges.

---

### **Implementation:**

**Step 1: Locate Quiz Logic**

Find the quiz scoring/result calculation:
```
Likely locations:
- /src/pages/quiz/results.tsx
- /src/lib/quiz/calculatePattern.ts
- /src/utils/quizScoring.js
```

**Step 2: Add Fallback Pattern**

**BEFORE:**
```javascript
function calculateDominantPattern(answers) {
  const scores = {
    disappearing: 0,
    apology_loop: 0,
    testing: 0,
    attraction_to_harm: 0,
    compliment_deflection: 0,
    draining_bond: 0,
    success_sabotage: 0,
  };
  
  // Calculate scores from answers
  answers.forEach(answer => {
    scores[answer.pattern] += answer.weight;
  });
  
  // Find highest score
  const maxScore = Math.max(...Object.values(scores));
  const dominantPattern = Object.keys(scores).find(
    key => scores[key] === maxScore
  );
  
  return patterns[dominantPattern]; // Returns null if maxScore is 0
}
```

**AFTER:**
```javascript
function calculateDominantPattern(answers) {
  const scores = {
    disappearing: 0,
    apology_loop: 0,
    testing: 0,
    attraction_to_harm: 0,
    compliment_deflection: 0,
    draining_bond: 0,
    success_sabotage: 0,
  };
  
  // Calculate scores from answers
  answers.forEach(answer => {
    scores[answer.pattern] += answer.weight;
  });
  
  // Find highest score
  const maxScore = Math.max(...Object.values(scores));
  
  // FALLBACK: If no dominant pattern (all scores = 0 or tied)
  if (maxScore === 0) {
    return {
      pattern_id: 'mixed',
      pattern_name: 'Mixed Patterns',
      pattern_description: 'Your patterns are currently in flux or evenly distributed. This is common during transition periods.',
    };
  }
  
  // FALLBACK: If multiple patterns tied at max score
  const topPatterns = Object.keys(scores).filter(
    key => scores[key] === maxScore
  );
  
  if (topPatterns.length > 1) {
    return {
      pattern_id: 'hybrid',
      pattern_name: `${topPatterns.length}-Pattern Hybrid`,
      pattern_description: `You're running ${topPatterns.length} patterns simultaneously: ${topPatterns.map(p => patterns[p].pattern_name).join(', ')}. This is your nervous system's layered response.`,
      primary_patterns: topPatterns.map(p => patterns[p]),
    };
  }
  
  // Normal case: Single dominant pattern
  const dominantPattern = topPatterns[0];
  return patterns[dominantPattern];
}
```

**Step 3: Create Fallback Pattern Definitions**

Add fallback patterns to your patterns database/config:

```javascript
const patterns = {
  disappearing: {
    pattern_id: 'disappearing',
    pattern_name: 'Disappearing Pattern',
    // ... existing data
  },
  // ... other patterns
  
  // FALLBACK PATTERNS
  mixed: {
    pattern_id: 'mixed',
    pattern_name: 'Mixed Patterns',
    pattern_description: 'Your assessment shows no single dominant pattern. This typically means:\n\n1. You're in a transition phase between patterns\n2. Your nervous system is actively recoding\n3. You need more specific context\n\nRecommendation: Start with the 7-Day Crash Course to identify which body signatures are most active.',
    body_signature: 'Varied responses across situations',
    circuit_break: 'Take the assessment again in 24 hours after observing your reactions in real situations.',
    cta_text: 'Start Crash Course',
    cta_url: '/portal/crash-course',
  },
  
  hybrid: {
    pattern_id: 'hybrid',
    pattern_name: 'Multi-Pattern System',
    pattern_description: 'Your nervous system is running multiple patterns simultaneously. This is your body's layered protection mechanism.\n\nThis isn't "complexity" - it's precision. Each pattern serves a specific context.',
    body_signature: 'Context-dependent pattern switching',
    circuit_break: 'Identify which pattern runs in which context: work vs. relationships vs. family.',
    cta_text: 'Get Full Pattern Map',
    cta_url: '/pricing',
  },
};
```

**Step 4: Update Results Page**

Handle fallback patterns in the UI:

```jsx
export default function QuizResults({ pattern }) {
  // Check if fallback pattern
  const isFallback = pattern.pattern_id === 'mixed' || pattern.pattern_id === 'hybrid';
  
  return (
    <div className="quiz-results">
      <h1>Your Pattern: {pattern.pattern_name}</h1>
      
      {isFallback && (
        <div className="fallback-notice">
          <p>‚ö†Ô∏è Assessment shows mixed or unclear results</p>
        </div>
      )}
      
      <div className="pattern-description">
        <p>{pattern.pattern_description}</p>
      </div>
      
      {pattern.pattern_id === 'hybrid' && pattern.primary_patterns && (
        <div className="hybrid-breakdown">
          <h2>Your Primary Patterns:</h2>
          <ul>
            {pattern.primary_patterns.map(p => (
              <li key={p.pattern_id}>
                <strong>{p.pattern_name}</strong>
                <p>{p.pattern_description}</p>
              </li>
            ))}
          </ul>
        </div>
      )}
      
      <div className="cta-section">
        <a href={pattern.cta_url} className="cta-primary">
          {pattern.cta_text}
        </a>
      </div>
    </div>
  );
}
```

**Step 5: Add Error Boundary**

Wrap quiz in error boundary as final safety net:

```jsx
// /components/quiz/QuizErrorBoundary.tsx
import { Component } from 'react';

export class QuizErrorBoundary extends Component {
  state = { hasError: false, error: null };
  
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  
  componentDidCatch(error, info) {
    console.error('Quiz error:', error, info);
    
    // Log to error tracking service
    // logErrorToService(error, info);
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <div className="quiz-error">
          <h2>Assessment Error</h2>
          <p>We couldn't calculate your pattern. This usually means:</p>
          <ul>
            <li>Network connection interrupted</li>
            <li>Browser blocked the response</li>
            <li>Technical glitch on our end</li>
          </ul>
          <button onClick={() => window.location.reload()}>
            Retry Assessment
          </button>
          <a href="/portal/crash-course">
            Skip to Crash Course
          </a>
        </div>
      );
    }
    
    return this.props.children;
  }
}

// Usage:
<QuizErrorBoundary>
  <Quiz />
</QuizErrorBoundary>
```

---

### **Testing Checklist:**

**Edge Cases:**
- [ ] All "Neutral" answers - shows "Mixed Patterns" result
- [ ] All "Strongly Agree" to one pattern - shows that pattern (normal case)
- [ ] Two patterns tied at max score - shows "Hybrid" result
- [ ] Three+ patterns tied - shows "Multi-Pattern" result
- [ ] Random mix of answers - shows dominant pattern (normal case)

**Fallback Patterns:**
- [ ] "Mixed Patterns" result page loads correctly
- [ ] Description is helpful, not confusing
- [ ] CTA directs to Crash Course (appropriate next step)
- [ ] "Hybrid" result shows all tied patterns
- [ ] Each pattern in hybrid view is clickable/readable

**Error Handling:**
- [ ] JavaScript error caught by error boundary
- [ ] User sees helpful error message
- [ ] "Retry Assessment" button works
- [ ] "Skip to Crash Course" link works
- [ ] Error logged for debugging

**User Experience:**
- [ ] Fallback results feel intentional, not broken
- [ ] User understands what "Mixed" or "Hybrid" means
- [ ] Clear next step provided
- [ ] No technical jargon in error messages

### **Time Estimate:** 2 hours

---

## TOTAL FIX TIME: 8.5 HOURS

**Breakdown:**
1. Brand Violation (Healing) - 15 minutes
2. Mobile Table Overflow - 1 hour
3. Portal Upgrade Link - 2 hours
4. Admin Session Timeout - 3 hours
5. Quiz Fallback Logic - 2 hours
6. Testing all fixes - 30 minutes

---

## DEPLOYMENT CHECKLIST

**Pre-Deployment:**
- [ ] All 5 fixes implemented
- [ ] All tests passed
- [ ] No regressions found
- [ ] Code reviewed

**Deployment:**
- [ ] Deploy to production
- [ ] Verify all fixes live
- [ ] Test critical paths
- [ ] Monitor for errors

**Post-Deployment:**
- [ ] Search site for "healing" - zero results
- [ ] Test mobile pricing table on iPhone
- [ ] Test upgrade button - goes to checkout
- [ ] Verify admin session expires after 60 min
- [ ] Test quiz with all neutral answers

---

## LAUNCH READINESS: READY AFTER FIXES

**With these 5 fixes complete:**
- Site Health Score: 78/100 ‚Üí 90/100
- Launch Status: READY WITH CAVEATS ‚Üí READY TO LAUNCH

**Launch Timeline:**
- Day 1: Implement fixes (8.5 hours)
- Day 2: Test thoroughly (2 hours)
- Day 3: LAUNCH

---

**Hand these specs to Replit one at a time.**

**Test each fix before moving to the next.**

**You're 48 hours from launch.**
